<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8"/>
    <title>Inside Lucene</title>

    <link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/reveal.css">
	<link rel="stylesheet" href="http://lab.hakim.se/reveal-js/css/theme/black.css" id="theme">
	<link rel="stylesheet" href="http://lab.hakim.se/reveal-js/lib/css/zenburn.css" id="theme">
    <style>
      .reveal ul {
        display: block;
        margin-left: 2em;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Inside Lucene</h1>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ##Full Text Index

              * Сложность поиска терма - O(1)
              * Wildcard запросы
              * Поиск по фразе
              * Минимальный размер
            </script>
            <!--
                Размер индекса очень важен, так как улучшает использование дискового кеша.
                Процессоры реально быстрые - раскодировать данные в памяти может оказаться бестрее, чем скопировать их.
                Для упрощения примем, что наш индекс должен быть неизменяемым
                (иммутабельность позволяет активно использовать кеширование).
              -->
          </section>
        </section>
        <section>
          <section data-markdown>
            <script type="text/template">
              ## Inverted Index
              <pre><code class="python">
docs = [
    {"id": "doc1", "status": 2, "name": "the brown fox"},
    {"id": "doc2", "status": 0, "name": "the brown"},
    {"id": "doc3", "name": "the the"},
]
index["name"] = {
    "brown": ["doc1", "doc2"],
    "fox": ["doc1"],
    "the": ["doc1", "doc2", "doc3"],
}
              </code></pre>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Document Ordinals

              <pre><code class="hlpython">
index["name"] = {
    "brown": [0, 1],
    "fox": [0],
    "the": [0, 1, 2],
}
ordinals = ["doc1", "doc2", "doc3"]
              </code></pre>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Frequency & Positions

              * Скоринг
              * Поиск по фразе

              <pre><code class="hlpython">
index["name"] = {
    "brown": ([0, 1], [1, 1], [[1], [1]]),
    "fox": ([0], [1], [[2]]),
    "the": ([0, 1, 2], [1, 1, 2], [[0], [0], [0, 1]])
}
ordinals = ["doc1", "doc2", "doc3"]
              </code></pre>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Uninverted index

              * Сортировка
              * Скрипты
              * Агрегации

              Раньше FieldCache индекс загружался в память

              <pre><code class="hlpython">
doc_values["status"] = {
    0: 2,
    1: 0,
    2: None,
}
              </code></pre>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Term vectors

              * Инвертрованный индекс для каждого документа
              * Хранит частоту терма, позиции, смещения в тексте
              * Используется для подсветки

              <pre><code class="hlpython">
vectors = {
    0: {"name": {
        "brown": (1, [2], [[4, 9]]),
        "fox": (1, [3], [[10, 13]]),
        "the": (1, [1], [[0, 3]]),
    }},
    1: {"name": {
        "brown": (1, [2], [[4, 9]]),
        "the": (1, [1], [[0, 3]]),
    }},
    2: {"name": {
        "the": (1, [1, 2], [[0, 3], [4, 7]]),
    }},
}
              </code></pre>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Stored

              * Оригинальное значение поля
              * Сжимается LZ4 или GZIP блоками по 16Кб
              * Распаковывается весь блок
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Compress Postings List
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Delta + VInt

              <pre><code class="python">
                  [2, 8, 9, 10, 27, 35, 62]
                  [2, 6, 1, 1, 17, 8, 27]
              </code></pre>

              Variable Integers - старший бит байта кодирует есть ли продолжение.
              Закодированный Integer занимает от 1 до 5 байт.

              Минусы:

              * Плохо работает с предсказателем переходов
              * Минимальный размер - 1 байт
              * Нельзя раскодировать произвольное значение
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Frame of Reference

              <pre><code class="python">
                [2, 8, 9, 10, 27, 35, 62]
                (6, 2, [0, 6, 1, 1, 17, 8, 27])
              </code></pre>

              * Фиксированный размер
              * Единственное большое значение увеличивает размер
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Patched Frame of Reference

              <pre><code class="python">
                [2, 8, 9, 10, 27, 35, 62]
                (3, 2, [0, 6, 1, 1]), (5, 17, [0, 8, 27])
              </code></pre>

              * Блок состоит из 256 значений
              * Большие значения влияют только на один блок
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Filter Cache

              * Должны ускорять выполнение часто используемых фильтров
              * Ключ - это пара (filter, segment)
              * Степень сжатия не так важна - скорость важнее
            </script>
            <!--
                Я здесь написал "должны", так как не обязательно они будут ускорять.
                Важно кешировать действительно часто используемые фильтры, иначе
                записи в кеше будут постоянно вытеснять друг друга.
                Записи привязаны к сегментам, благодаря иммутабельности последних,
                запись в кеше всегда актуальна.
                Хоть сжатие не так важно как для индекса, но все же чем меньше будет
                занимать запись в кеше, тем больше записей мы можем хранить. Нужен компромис.n
              -->
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Sorted Integer

              * Самый простой способ
              * 1 миллион документов занимает 4Мб
              * Нужно что-то более эфективное по памяти
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Bitmaps

              * Лучший способ для "плотных" фильтров
              * 1 миллион документов занимает 125Кб
              * Неэфективен для сильно разреженых фильтров
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Roaring Bitmaps

              * Взял лучшее из обоих способов
              * Разбивает на блоки по 16 старшим битам
              * Внутри блока сохраняет только 16 младших бит
              * Если в блоке меньше 4096 значений использует массив, иначе bitmap
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Roaring Bitmaps

              <pre><code class="python">
                [2, 8, 9, 10, 12, 35, 62]
                [(0, 2), (0, 8), (0, 9), (0, 10), (0, 12), (2, 3), (3, 14)]
                [(0, 0b0001_0111_0000_0100), (1,), (2, [3]), (3, [14])]
              </code></pre>
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Finite State Transducer

              * Нахождение по ключу за O(1), зависит только от длинны ключа
              * Поиск ключей по префиксу
              * Отличное сжатие для естественных языков

            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Finite State Transducer

              <pre>
                0: mop    3: star
                1: moth   4: stop
                2: pop    5: top
              </pre>

              ![FST](images/numericFST.png)
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ## Numeric Fields

              * Используют префиксное дерево - Trie

              ![Trie](images/trie.png)

              <pre>
                423 &lt;= price &lt;= 642

                5 | 44 | 63 | 423 | 641 | 642
              </pre>
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Codecs

              Кодеки в Lucene - это плагины

              <pre><code class="python">
def writerConfig = new IndexWriterConfig(new StandardAnalyzer())
writerConfig.setUseCompoundFile(false)
writerConfig.setCodec(new SimpleTextCodec())

def writer = new IndexWriter(dir, writerConfig)

def doc = new Document()
doc.add(new StringField('id', '1', Field.Store.YES))
doc.add(new IntField('status', 1, Field.Store.NO))
doc.add(new NumericDocValuesField('status', 1))
doc.add(new TextField('name', 'the brown fox', Field.Store.NO))
writer.addDocument(doc)
// add another documents ...

writer.close()
              </code></pre>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Codecs

              <pre><code class="bash">
$ cat data/_0.pst
...
field name
  term brown
    doc 0
      freq 1
      pos 1
    doc 1
      freq 1
      pos 1
  term fox
    doc 0
      freq 1
      pos 0
              </code></pre>
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Segments

              * Немутабельныe
              * Документ нельзя удалить
              * Merges
              * Compound segments для уменьшения кол-ва открытых файлов
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Live Docs

              * Единственная мутабельная часть сегмента
              * Внутри Bitmap с пропусками
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Merging Segments

              <iframe width="560" height="315" src="https://www.youtube.com/embed/YOklKW9LJNY" frameborder="0" allowfullscreen></iframe>
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Ranking &amp; Similarity

              * TF - частота терма в документе
              * tf(t, d) = sqrt(frequency)
              * IDF - инвертированная частота терма в корпусе
              * idf(t) = 1 + log(numDocs / (docFreq + 1))
              * norm = 1 / sqrt(numTerms)
              * score ~ tf * idf * norm
              * BM25 - тонкая настройка
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Vector Space Model

              ![Vector](images/vector_query.png)
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ## Text processing

              * Фильтрация символов (например удаление html)
              * Разбиение на токены
              * Морфология (стемминг)
              * Синонимы
              * Разделение/объединение (wi fi = wifi = WiFi = wi-fi)
              * Нижний регистр
              * Машинное обучение
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ## Normalization

              * Snowball - алгоритмический стеммер
              * Hunspell - медленно
              * Pymorphy2 - быстро и точно
            </script>
          </section>
        </section>
      </div>
    </div>

    <script src="http://lab.hakim.se/reveal-js/lib/js/head.min.js"></script>
    <script src="http://lab.hakim.se/reveal-js/js/reveal.js"></script>
    <script>
      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
	progress: true,
        history: true,
        center: true,
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // Optional reveal.js plugins
        dependencies: [
          {
            src: 'http://lab.hakim.se/reveal-js/lib/js/classList.js',
            condition: function() { return !document.body.classList; }
          },
          {
            src: 'http://lab.hakim.se/reveal-js/plugin/markdown/marked.js',
            condition: function() { return !!document.querySelector( '[data-markdown]' ); }
          },
          {
            src: 'http://lab.hakim.se/reveal-js/plugin/markdown/markdown.js',
            condition: function() { return !!document.querySelector( '[data-markdown]' ); }
          },
          {
            src: 'http://lab.hakim.se/reveal-js/plugin/highlight/highlight.js',
            async: true,
            condition: function() { return !!document.querySelector( 'pre code' ); },
            callback: function() { hljs.initHighlightingOnLoad(); }
          },
          {
            src: 'http://lab.hakim.se/reveal-js/plugin/zoom-js/zoom.js',
            async: true
          },
          {
            src: 'http://lab.hakim.se/reveal-js/plugin/notes/notes.js',
            async: true
          }
        ]
      });
      console.log(" * End of init!");
    </script>
  </body>
</html>
